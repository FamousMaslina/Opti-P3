# plugins/op2layer.py
# OP2 Compatibility Layer for OP3
# - Spoofs op2v/op2api versions
# - Runs legacy OP2-era programs under OP3 via a shimmed PYTHONPATH
# - Provides a settings menu for persistent spoof values
#
# OP3 calls this module as a plugin (no edits to op3.py needed).
# Exposes commands: op2run, op2layer, op2, op2spoof

import os
import sys
import shlex
import time
import subprocess
import configparser

# ---------- Plugin metadata (used by OP3 manage_extensions) ----------
info = {
    "title": "OP2 Compatibility Layer",
    "version": "rc-0.1.0",
    "author": "FamousMaslina+ChatGPT-5-Thinking-Extended",
    "description": "Run OP2 programs inside OP3 with spoofed OP2/API versions."
}

# ---------- Paths ----------
THIS_DIR = os.path.dirname(os.path.abspath(__file__))
BASE_DIR = os.path.abspath(os.path.join(THIS_DIR, ".."))  # OP3 root (has hw/, sys/, programs/, plugins/)
INI_DIR  = os.path.join(BASE_DIR, "sys", "ini")
INI_PATH = os.path.join(INI_DIR, "op2layer.ini")
SHIM_DIR = os.path.join(BASE_DIR, "sys", "op2shim")       # contains runtime shim modules (op2v.py / op2api.py)
PROGRAMS_DIR = os.path.join(BASE_DIR, "programs")

# ---------- Defaults ----------
DEFAULTS = {
    "op2_ver":       "0.9.4",
    "op2_veri":      "0.9",
    "op2_verstring": "1A",
    "api_ver":       "0.8",
    "api_veri":      "0.8",
    "legacy":        "0"   
}

# ---------- Config helpers ----------
def _ensure_dirs():
    os.makedirs(INI_DIR, exist_ok=True)
    os.makedirs(SHIM_DIR, exist_ok=True)

def _load_cfg():
    _ensure_dirs()
    cfg = configparser.ConfigParser()
    if os.path.exists(INI_PATH):
        cfg.read(INI_PATH)
    if "spoof" not in cfg:
        cfg["spoof"] = DEFAULTS.copy()
    # fill missing values with defaults
    for k, v in DEFAULTS.items():
        if k not in cfg["spoof"]:
            cfg["spoof"][k] = v
    return cfg

def _save_cfg(cfg):
    _ensure_dirs()
    with open(INI_PATH, "w") as f:
        cfg.write(f)

# ---------- Shim writers ----------
def _write_op2v(cfg, override=None):
    vals = dict(cfg["spoof"])
    if override:
        vals.update(override)
    py = f"""# Auto-generated by OP2 Layer
op2VER = "{vals['op2_ver']}"
op2VERI = {float(vals['op2_veri']):.3f}
op2VERSTRING = "{vals['op2_verstring']}"
"""
    with open(os.path.join(SHIM_DIR, "op2v.py"), "w", encoding="utf-8") as f:
        f.write(py)

def _write_op2api(cfg, override=None):
    vals = dict(cfg["spoof"])
    if override:
        vals.update(override)

    lega_bool = "True" if str(vals.get("legacy", "0")) == "1" else "False"
    api_ver = vals["api_ver"]
    api_veri = float(vals["api_veri"])
    op2_ver = vals["op2_ver"]
    op2_verstring = vals["op2_verstring"]

    py = f'''# Auto-generated by OP2 Layer
# Intentionally permissive, provides the "god-object" surface OP2-era apps expect.

import os as os
import sys as sys
import time as time
import configparser as _cfg

# ---- Public version flags ----
lega = {lega_bool}                 # legacy flag expected by some OP2 apps
apiver = "{api_ver}"
apiverI = {api_veri:.3f}

# Keep these around for apps that *read* them from op2api:
compver  = "{op2_ver}"
compver2 = "{op2_ver} R2"
compver3 = "{op2_ver}.1"
compver4 = "{op2_ver}"
compver5 = "{op2_ver} R2"
compver6 = "{op2_ver}.2"

# ---- Aliases expected by OP2 code ----
ConfigParser = _cfg.ConfigParser

def linebr(n):
    try:
        n = int(n)
    except Exception:
        n = 20
    print("=" * n)

def linebr2(n):
    try:
        n = int(n)
    except Exception:
        n = 20
    print("-" * n)

# Try to borrow OP3 helpers where possible
try:
    import op3 as _op3
    if getattr(_op3, 'hw_manager', None) is None:
        _op3.init_hw()
    def clear():
        try:
            return _op3.clear()
        except Exception:
            pass
        os.system('cls' if os.name == 'nt' else 'clear')
except Exception:
    _op3 = None
    def clear():
        os.system('cls' if os.name == 'nt' else 'clear')

# ---- Hardware bindings (cpu_module / mb_module / hd_module) ----
_cpu = _op3.hw_manager.get_component('cpu') if (_op3 and _op3.hw_manager) else None
_mb  = _op3.hw_manager.get_component('mb')  if (_op3 and _op3.hw_manager) else None
_hd  = _op3.hw_manager.get_component('hd')  if (_op3 and _op3.hw_manager) else None

class _Compat:
    def __init__(self, obj, mapping):
        self._o = obj
        self._m = mapping or {{}}
    def __getattr__(self, name):
        if self._o is None:
            raise AttributeError(name)
        if hasattr(self._o, name):
            return getattr(self._o, name)
        alt = self._m.get(name)
        if isinstance(alt, str) and hasattr(self._o, alt):
            return getattr(self._o, alt)
        if callable(alt):
            return alt(self._o)
        raise AttributeError(name)

def _mb_memKB(o):
    # try several common spellings; default 4096
    for k in ('mMem', 'mbMem', 'mbMemKB'):
        if hasattr(o, k):
            try:
                return int(getattr(o, k))
            except Exception:
                pass
    return 4096

def _mb_memSTR(o):
    for k in ('mMemS', 'mbMemSTR'):
        if hasattr(o, k):
            return getattr(o, k)
    # format the numeric KB into string if possible
    return f"{{_mb_memKB(o)}} KB"

_mb_map = {{
    # OP2 code often uses mName / mMemS; OP3 mb uses mbName / mbMemSTR
    "mName": "mbName",
    "mMemS": "mbMemSTR",
    "mMem":  _mb_memKB,
}}

cpu_module = _cpu
mb_module  = _Compat(_mb, _mb_map) if _mb else None
hd_module  = _hd  # OP2 hw likely already uses hddnameS/hddspaceS; leave as-is.

# ---- Timing helpers expected by OP2 apps ----
def sleep_timecustom(sec, cFreq):
    try:
        return float(sec) / float(cFreq)
    except Exception:
        return 0.5

def sleep_timeAppLoad(cFreq):
    try:
        return 13.0 / float(cFreq)
    except Exception:
        return 0.5

def sleep_timeInAppLoad(cFreq):
    try:
        return 2.0 / float(cFreq)
    except Exception:
        return 0.1

try:
    _cf = getattr(cpu_module, 'cFreq', None)
    sleep_timeIAppL = sleep_timeInAppLoad(_cf) if _cf else 0.1
except Exception:
    sleep_timeIAppL = 0.1

# ---- Minimal no-op helper used by some setups ----
def configFile(var, filename):
    cfg = ConfigParser()
    with open(filename, 'w', encoding='utf-8') as f:
        cfg.write(f)
    return cfg

# ---- Compatibility check ----
def check():
    try:
        print("API version", apiverI)
        print("API Check done!")
    except Exception:
        pass
    return True
'''
    with open(os.path.join(SHIM_DIR, "op2api.py"), "w", encoding="utf-8") as f:
        f.write(py)


def _prepare_shims(spoof_overrides=None):
    cfg = _load_cfg()
    _write_op2v(cfg, spoof_overrides)
    _write_op2api(cfg, spoof_overrides)

# ---------- Resolution helpers ----------
def _resolve_target(path_like: str) -> str:
    """
    Resolve a program path:
    - bare filename -> programs/<name>
    - relative/absolute paths -> unchanged if exists
    """
    cand = path_like
    if not os.path.isabs(cand):
        # if it's just a filename, search in /programs by default
        base_cand = os.path.join(PROGRAMS_DIR, cand)
        if os.path.exists(base_cand):
            return base_cand
        # try relative to current directory inside OP3 shell
        rel_cand = os.path.join(os.getcwd(), cand)
        if os.path.exists(rel_cand):
            return rel_cand
        # also try programs/ plus 'programs/' prefix if user typed that already
        if cand.startswith("programs" + os.sep):
            other = os.path.join(BASE_DIR, cand)
            if os.path.exists(other):
                return other
    else:
        if os.path.exists(cand):
            return cand

    raise FileNotFoundError(f"Program not found: {path_like}")

def _parse_overrides(args):
    """
    Parse CLI-ish overrides:
      --api X.Y   (string)
      --op2 X.Y.Z (string)
      --tag STR   (verstring)
      --apii 0.8  (float)
      --op2i 0.9  (float)
    """
    overrides = {}
    i = 0
    while i < len(args):
        a = args[i]
        if a == "--api" and i+1 < len(args):
            overrides["api_ver"] = args[i+1]; i += 2
        elif a == "--apii" and i+1 < len(args):
            overrides["api_veri"] = args[i+1]; i += 2
        elif a == "--op2" and i+1 < len(args):
            overrides["op2_ver"] = args[i+1]; i += 2
        elif a == "--op2i" and i+1 < len(args):
            overrides["op2_veri"] = args[i+1]; i += 2
        elif a == "--tag" and i+1 < len(args):
            overrides["op2_verstring"] = args[i+1]; i += 2
        elif a == "--legacy":
            overrides["legacy"] = "1"; i += 1
        elif a == "--no-legacy":
            overrides["legacy"] = "0"; i += 1
        else:
            # stop on first unknown flag (the rest are program args)
            break
    return overrides, args[i:]

# ---------- Runner ----------
def _run_under_op2(target_file: str, prog_args):
    """
    Run target_file in a subprocess with shims available on PYTHONPATH.
    """
    #_prepare_shims()  # ensure current config is written
    env = os.environ.copy()

    shim_plus = SHIM_DIR
    # Include OP3 base as well so legacy imports can still find modules
    shim_plus = os.pathsep.join([SHIM_DIR, BASE_DIR, env.get("PYTHONPATH", "")])
    env["PYTHONPATH"] = shim_plus

    # Workdir = file's folder (legacy programs often assume CWD-local resources)
    workdir = os.path.dirname(os.path.abspath(target_file)) or BASE_DIR

    cmd = [sys.executable, "-u", target_file] + list(prog_args)
    try:
        proc = subprocess.run(cmd, cwd=workdir, env=env)
        return proc.returncode
    except FileNotFoundError:
        print(f"Python could not execute: {target_file}")
        return 127
    except Exception as e:
        print(f"Error running OP2 program: {e}")
        return 1

# ---------- UI ----------
def _settings_menu():
    cfg = _load_cfg()
    while True:
        os.system('cls' if os.name == 'nt' else 'clear')
        print("OP2 Layer – Spoof Settings")
        print("=" * 36)
        s = cfg["spoof"]
        print(f"1) OP2  version     : {s['op2_ver']}")
        print(f"2) OP2  version (I) : {s['op2_veri']}")
        print(f"3) OP2  tag/STRING  : {s['op2_verstring']}")
        print(f"4) API  version     : {s['api_ver']}")
        print(f"5) API  version (I) : {s['api_veri']}")
        print("-" * 36)
        print("S) Save    Q) Quit without saving")
        choice = input("> ").strip().lower()

        if choice == "1":
            s["op2_ver"] = input("New OP2 version (e.g., 0.9.4): ").strip() or s["op2_ver"]
        elif choice == "2":
            s["op2_veri"] = input("New OP2 version (float, e.g., 0.9): ").strip() or s["op2_veri"]
        elif choice == "3":
            s["op2_verstring"] = input("New OP2 tag (e.g., 1A): ").strip() or s["op2_verstring"]
        elif choice == "4":
            s["api_ver"] = input("New API version (e.g., 0.8): ").strip() or s["api_ver"]
        elif choice == "5":
            s["api_veri"] = input("New API version (float, e.g., 0.8): ").strip() or s["api_veri"]
        elif choice == "s":
            _save_cfg(cfg)
            print("Saved.")
            time.sleep(0.8)
        elif choice == "q":
            break

def _print_help():
    print("""
OP2 Layer – Help
================
Run legacy OP2-era programs under OP3 with spoofed versions.

Commands:
  op2run <program.py> [--api X.Y] [--apii X.Y] [--op2 X.Y.Z] [--op2i X.Y] [--tag STR] [-- <args...>]
    - Runs the target program with op2v/op2api shims.
    - If <program.py> is a bare name, searches in 'programs/'.

  op2layer
  op2spoof
  op2
    - Open spoof settings menu.

Examples:
  op2run nguess.py
  op2run programs/nguess.py --api 0.8 --op2 0.9.4 --tag 1A
  op2run legacy_game.py -- --fast --seed=42   # pass args to program after '--'
""")

# ---------- Command entrypoints (OP3 calls these with *args) ----------
def op2layer_cmd(*args):
    # If args look like a file, act like op2run; otherwise open settings.
    if args and args[0].endswith(".py"):
        return op2run_cmd(*args)
    _settings_menu()

def op2spoof_cmd(*_args):
    _settings_menu()

def op2run_cmd(*args):
    if not args:
        _print_help()
        return
    # split program args from our override flags; allow passing '--' to force-stop parsing
    args = list(args)
    if "--" in args:
        sep_idx = args.index("--")
        my_flags = args[1:sep_idx] if len(args) > 1 else []
        prog_args = args[sep_idx+1:]
    else:
        my_flags = args[1:]
        prog_args = []

    target = _resolve_target(args[0])
    overrides, remainder = _parse_overrides(my_flags)
    prog_args = remainder + prog_args

    # apply one-shot overrides by re-writing shims
    _prepare_shims(overrides if overrides else None)
    rc = _run_under_op2(target, prog_args)
    if rc != 0:
        print(f"(op2layer) Program exited with code {rc}")

def op2_help_cmd(*_):
    _print_help()

# ---------- Exposed commands dict ----------
commands = {
    "op2layer": op2layer_cmd,
    "op2": op2layer_cmd,          # alias
    "op2spoof": op2spoof_cmd,
    "op2run": op2run_cmd,
    "op2help": op2_help_cmd,
}
