# Auto-generated by OP2 Layer
# Intentionally permissive, provides the "god-object" surface OP2-era apps expect.

import os as os
import sys as sys
import time as time
import configparser as _cfg

# ---- Public version flags ----
lega = False                 # legacy flag expected by some OP2 apps
apiver = "0.8"
apiverI = 0.800

# Keep these around for apps that *read* them from op2api:
compver  = "0.9.4"
compver2 = "0.9.4 R2"
compver3 = "0.9.4.1"
compver4 = "0.9.4"
compver5 = "0.9.4 R2"
compver6 = "0.9.4.2"

# ---- Aliases expected by OP2 code ----
ConfigParser = _cfg.ConfigParser

def linebr(n):
    try:
        n = int(n)
    except Exception:
        n = 20
    print("=" * n)

def linebr2(n):
    try:
        n = int(n)
    except Exception:
        n = 20
    print("-" * n)

# Try to borrow OP3 helpers where possible
try:
    import op3 as _op3
    if getattr(_op3, 'hw_manager', None) is None:
        _op3.init_hw()
    def clear():
        try:
            return _op3.clear()
        except Exception:
            pass
        os.system('cls' if os.name == 'nt' else 'clear')
except Exception:
    _op3 = None
    def clear():
        os.system('cls' if os.name == 'nt' else 'clear')

# ---- Hardware bindings (cpu_module / mb_module / hd_module) ----
_cpu = _op3.hw_manager.get_component('cpu') if (_op3 and _op3.hw_manager) else None
_mb  = _op3.hw_manager.get_component('mb')  if (_op3 and _op3.hw_manager) else None
_hd  = _op3.hw_manager.get_component('hd')  if (_op3 and _op3.hw_manager) else None

class _Compat:
    def __init__(self, obj, mapping):
        self._o = obj
        self._m = mapping or {}
    def __getattr__(self, name):
        if self._o is None:
            raise AttributeError(name)
        if hasattr(self._o, name):
            return getattr(self._o, name)
        alt = self._m.get(name)
        if isinstance(alt, str) and hasattr(self._o, alt):
            return getattr(self._o, alt)
        if callable(alt):
            return alt(self._o)
        raise AttributeError(name)

def _mb_memKB(o):
    # try several common spellings; default 4096
    for k in ('mMem', 'mbMem', 'mbMemKB'):
        if hasattr(o, k):
            try:
                return int(getattr(o, k))
            except Exception:
                pass
    return 4096

def _mb_memSTR(o):
    for k in ('mMemS', 'mbMemSTR'):
        if hasattr(o, k):
            return getattr(o, k)
    # format the numeric KB into string if possible
    return f"{_mb_memKB(o)} KB"

_mb_map = {
    # OP2 code often uses mName / mMemS; OP3 mb uses mbName / mbMemSTR
    "mName": "mbName",
    "mMemS": "mbMemSTR",
    "mMem":  _mb_memKB,
}

cpu_module = _cpu
mb_module  = _Compat(_mb, _mb_map) if _mb else None
hd_module  = _hd  # OP2 hw likely already uses hddnameS/hddspaceS; leave as-is.

# ---- Timing helpers expected by OP2 apps ----
def sleep_timecustom(sec, cFreq):
    try:
        return float(sec) / float(cFreq)
    except Exception:
        return 0.5

def sleep_timeAppLoad(cFreq):
    try:
        return 13.0 / float(cFreq)
    except Exception:
        return 0.5

def sleep_timeInAppLoad(cFreq):
    try:
        return 2.0 / float(cFreq)
    except Exception:
        return 0.1

try:
    _cf = getattr(cpu_module, 'cFreq', None)
    sleep_timeIAppL = sleep_timeInAppLoad(_cf) if _cf else 0.1
except Exception:
    sleep_timeIAppL = 0.1

# ---- Minimal no-op helper used by some setups ----
def configFile(var, filename):
    cfg = ConfigParser()
    with open(filename, 'w', encoding='utf-8') as f:
        cfg.write(f)
    return cfg

# ---- Compatibility check ----
def check():
    try:
        print("API version", apiverI)
        print("API Check done!")
    except Exception:
        pass
    return True
